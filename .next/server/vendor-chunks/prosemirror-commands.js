"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-commands";
exports.ids = ["vendor-chunks/prosemirror-commands"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* binding */ autoJoin),\n/* harmony export */   baseKeymap: () => (/* binding */ baseKeymap),\n/* harmony export */   chainCommands: () => (/* binding */ chainCommands),\n/* harmony export */   createParagraphNear: () => (/* binding */ createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* binding */ deleteSelection),\n/* harmony export */   exitCode: () => (/* binding */ exitCode),\n/* harmony export */   joinBackward: () => (/* binding */ joinBackward),\n/* harmony export */   joinDown: () => (/* binding */ joinDown),\n/* harmony export */   joinForward: () => (/* binding */ joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* binding */ joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* binding */ joinTextblockForward),\n/* harmony export */   joinUp: () => (/* binding */ joinUp),\n/* harmony export */   lift: () => (/* binding */ lift),\n/* harmony export */   liftEmptyBlock: () => (/* binding */ liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* binding */ macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* binding */ newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* binding */ pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectNodeBackward: () => (/* binding */ selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* binding */ selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* binding */ selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* binding */ selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* binding */ selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* binding */ setBlockType),\n/* harmony export */   splitBlock: () => (/* binding */ splitBlock),\n/* harmony export */   splitBlockAs: () => (/* binding */ splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* binding */ splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* binding */ toggleMark),\n/* harmony export */   wrapIn: () => (/* binding */ wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n/**\nDelete the selection, if there is one.\n*/ const deleteSelection = (state, dispatch)=>{\n    if (state.selection.empty) return false;\n    if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before itâ€”if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/ const joinBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null) return false;\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(before, \"end\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`]($commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/ const joinTextblockBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`]($commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/ const joinTextblockForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for(; !beforeText.isTextblock; beforePos--){\n        if (beforeText.type.spec.isolating) return false;\n        let child = beforeText.lastChild;\n        if (!child) return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for(; !afterText.isTextblock; afterPos++){\n        if (afterText.type.spec.isolating) return false;\n        let child = afterText.firstChild;\n        if (!child) return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for(let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild){\n        if (scan.isTextblock) return true;\n        if (only && scan.childCount != 1) return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/ const selectNodeBackward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));\n        if ($pos.node(i).type.spec.isolating) break;\n    }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/ const joinForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut) return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch)) return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/ const selectNodeForward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        let parent = $pos.node(i);\n        if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));\n        if (parent.type.spec.isolating) break;\n    }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/ const joinUp = (state, dispatch)=>{\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) return false;\n        point = sel.from;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null) return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel) tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/ const joinDown = (state, dispatch)=>{\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) return false;\n        point = sel.to;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null) return false;\n    }\n    if (dispatch) dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/ const lift = (state, dispatch)=>{\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/ const newlineInCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i++){\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/ const exitCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type)) return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/ const createParagraphNear = (state, dispatch)=>{\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock) return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/ const liftEmptyBlock = (state, dispatch)=>{\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size) return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch) dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/ function splitBlockAs(splitNode) {\n    return (state, dispatch)=>{\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) return false;\n            if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.parent.isBlock) return false;\n        if (dispatch) {\n            let atEnd = $to.parentOffset == $to.parent.content.size;\n            let tr = state.tr;\n            if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection) tr.deleteSelection();\n            let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n            let splitType = splitNode && splitNode($to.parent, atEnd);\n            let types = splitType ? [\n                splitType\n            ] : atEnd && deflt ? [\n                {\n                    type: deflt\n                }\n            ] : undefined;\n            let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n            if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [\n                {\n                    type: deflt\n                }\n            ] : undefined)) {\n                if (deflt) types = [\n                    {\n                        type: deflt\n                    }\n                ];\n                can = true;\n            }\n            if (can) {\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n                    let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n                    if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/ const splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/ const splitBlockKeepMarks = (state, dispatch)=>{\n    return splitBlock(state, dispatch && ((tr)=>{\n        let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n        if (marks) tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/ const selectParentNode = (state, dispatch)=>{\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0) return false;\n    pos = $from.before(same);\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/ const selectAll = (state, dispatch)=>{\n    if (dispatch) dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type)) return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos))) return false;\n    if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    if (before.type.spec.isolating || after.type.spec.isolating) return false;\n    if (joinMaybeClear(state, $cut, dispatch)) return true;\n    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for(let i = conn.length - 1; i >= 0; i--)wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let joinAt = end + 2 * conn.length;\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt)) tr.join(joinAt);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for(;;){\n            wrap.push(at);\n            if (at.isTextblock) break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for(; !afterText.isTextblock; afterText = afterText.firstChild)afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for(let i = wrap.length - 1; i >= 0; i--)end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function(state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while($pos.node(depth).isInline){\n            if (!depth) return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock) return false;\n        if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/ const selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/ const selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/ function wrapIn(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping) return false;\n        if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/ function setBlockType(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let applicable = false;\n        for(let i = 0; i < state.selection.ranges.length && !applicable; i++){\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos)=>{\n                if (applicable) return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                } else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable) return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for(let i = 0; i < state.selection.ranges.length; i++){\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type) {\n    for(let i = 0; i < ranges.length; i++){\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node)=>{\n            if (can) return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can) return true;\n    }\n    return false;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/ function toggleMark(markType, attrs = null) {\n    return function(state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));\n                else dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            } else {\n                let has = false, tr = state.tr;\n                for(let i = 0; !has && i < ranges.length; i++){\n                    let { $from, $to } = ranges[i];\n                    has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n                }\n                for(let i = 0; i < ranges.length; i++){\n                    let { $from, $to } = ranges[i];\n                    if (has) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    } else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr)=>{\n        if (!tr.isGeneric) return dispatch(tr);\n        let ranges = [];\n        for(let i = 0; i < tr.mapping.maps.length; i++){\n            let map = tr.mapping.maps[i];\n            for(let j = 0; j < ranges.length; j++)ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to)=>ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for(let i = 0; i < ranges.length; i += 2){\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for(let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index){\n                let after = parent.maybeChild(index);\n                if (!after) break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b)=>a - b);\n        for(let i = joinable.length - 1; i >= 0; i--){\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i])) tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/ function autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node)=>isJoinable.indexOf(node.type.name) > -1 : isJoinable;\n    return (state, dispatch, view)=>command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/ function chainCommands(...commands) {\n    return function(state, dispatch, view) {\n        for(let i = 0; i < commands.length; i++)if (commands[i](state, dispatch, view)) return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/ const pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/ const macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor(let key in pcBaseKeymap)macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/ const baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0STtBQUN4RjtBQUNzQztBQUUxRjs7QUFFQSxHQUNBLE1BQU1jLGtCQUFrQixDQUFDQyxPQUFPQztJQUM1QixJQUFJRCxNQUFNRSxTQUFTLENBQUNDLEtBQUssRUFDckIsT0FBTztJQUNYLElBQUlGLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ0wsZUFBZSxHQUFHTSxjQUFjO0lBQ3RELE9BQU87QUFDWDtBQUNBLFNBQVNDLGFBQWFOLEtBQUssRUFBRU8sSUFBSTtJQUM3QixJQUFJLEVBQUVDLE9BQU8sRUFBRSxHQUFHUixNQUFNRSxTQUFTO0lBQ2pDLElBQUksQ0FBQ00sV0FBWUQsQ0FBQUEsT0FBTyxDQUFDQSxLQUFLRSxjQUFjLENBQUMsWUFBWVQsU0FDbkRRLFFBQVFFLFlBQVksR0FBRyxJQUN6QixPQUFPO0lBQ1gsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTUcsZUFBZSxDQUFDWCxPQUFPQyxVQUFVTTtJQUNuQyxJQUFJQyxVQUFVRixhQUFhTixPQUFPTztJQUNsQyxJQUFJLENBQUNDLFNBQ0QsT0FBTztJQUNYLElBQUlJLE9BQU9DLGNBQWNMO0lBQ3pCLCtDQUErQztJQUMvQyxJQUFJLENBQUNJLE1BQU07UUFDUCxJQUFJRSxRQUFRTixRQUFRTyxVQUFVLElBQUlDLFNBQVNGLFNBQVM3QixpRUFBVUEsQ0FBQzZCO1FBQy9ELElBQUlFLFVBQVUsTUFDVixPQUFPO1FBQ1gsSUFBSWYsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDYSxJQUFJLENBQUNILE9BQU9FLFFBQVFYLGNBQWM7UUFDeEQsT0FBTztJQUNYO0lBQ0EsSUFBSWEsU0FBU04sS0FBS08sVUFBVTtJQUM1Qiw4QkFBOEI7SUFDOUIsSUFBSSxDQUFDRCxPQUFPRSxJQUFJLENB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LE1BQU0sV0FBVztBQUM1RTs7OztBQUlBLEdBQ0EsTUFBTUUsYUFBYUwsTUFBTUYsZ0JBQWdCRDtBQUVpWiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYmxvZy8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzPzI4ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAsIFJlcGxhY2VTdGVwLCBjYW5Kb2luLCBqb2luUG9pbnQsIGNhblNwbGl0LCBSZXBsYWNlQXJvdW5kU3RlcCwgZmluZFdyYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4qL1xuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0ID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xucmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl04oCUaWZcbnRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG5JZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG50aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG5pbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4oYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSB0aGlzLCB0cnkgdG8gbGlmdFxuICAgIGlmICghJGN1dCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgLy8gQXBwbHkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKCFiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGJlbG93IGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBhYm92ZSBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVmb3JlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChiZWZvcmUuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkY3V0LnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkJhY2t3YXJkYF0oJGNvbW1hbmRzLmpvaW5CYWNrd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZVxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5Gb3J3YXJkYF0oJGNvbW1hbmRzLmpvaW5Gb3J3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXJcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBiZWZvcmVUZXh0ID0gYmVmb3JlLCBiZWZvcmVQb3MgPSAkY3V0LnBvcyAtIDE7XG4gICAgZm9yICg7ICFiZWZvcmVUZXh0LmlzVGV4dGJsb2NrOyBiZWZvcmVQb3MtLSkge1xuICAgICAgICBpZiAoYmVmb3JlVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBiZWZvcmVUZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyUG9zID0gJGN1dC5wb3MgKyAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgICAgIGlmIChhZnRlclRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGFmdGVyVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgYmVmb3JlUG9zLCBhZnRlclBvcywgU2xpY2UuZW1wdHkpO1xuICAgIGlmICghc3RlcCB8fCBzdGVwLmZyb20gIT0gYmVmb3JlUG9zIHx8XG4gICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCAmJiBzdGVwLnNsaWNlLnNpemUgPj0gYWZ0ZXJQb3MgLSBiZWZvcmVQb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChzdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUsIG9ubHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gKHNpZGUgPT0gXCJzdGFydFwiID8gc2Nhbi5maXJzdENoaWxkIDogc2Nhbi5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGJlZm9yZSB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbmJvdW5kIHRvIGtleXMgbGlrZSBiYWNrc3BhY2UsIGFmdGVyXG5bYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpIG9yIG90aGVyIGRlbGV0aW5nXG5jb21tYW5kcywgYXMgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3QgYWxsb3dcbmRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQmVmb3JlO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zIC0gbm9kZS5ub2RlU2l6ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhXG50ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2tcbmFuZCB0aGUgb25lIGFmdGVyIGl0LCBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXJcbmJsb2NrIGNsb3NlciB0byB0aGlzIG9uZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFdpbGwgdXNlIHRoZSB2aWV3XG5mb3IgYWNjdXJhdGUgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEkY3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gICAgLy8gVHJ5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBhYm92ZSBhbmQgc2VsZWN0IHRoZSBvbmUgYmVsb3cuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBjb21pbmcgYWZ0ZXIgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkXG50byBiZSBib3VuZCB0byBrZXlzIGxpa2UgZGVsZXRlLCBhZnRlclxuW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZCkgYW5kIHNpbWlsYXIgZGVsZXRpbmdcbmNvbW1hbmRzLCB0byBwcm92aWRlIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0XG5hbGxvdyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2sgb3IsIGlmIHRoZXJlIGlzIGEgdGV4dCBzZWxlY3Rpb24sIHRoZVxuY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aFxudGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4qL1xuY29uc3Qgam9pblVwID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAobm9kZVNlbCkge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLmZyb207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgICAgIGlmIChub2RlU2VsKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxudGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGpvaW5Eb3duID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLnRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkxpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbnNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG4qL1xuY29uc3QgbGlmdCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiovXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aXRoIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGNyZWF0ZSBhXG5kZWZhdWx0IGJsb2NrIGFmdGVyIHRoZSBjb2RlIGJsb2NrLCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRoZXJlLlxuKi9cbmNvbnN0IGV4aXRDb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWJvdmUgPSAkaGVhZC5ub2RlKC0xKSwgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSwgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG5pdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KCR0by5wYXJlbnQuY29udGVudE1hdGNoQXQoJHRvLmluZGV4QWZ0ZXIoKSkpO1xuICAgIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2lkZSA9ICghJGZyb20ucGFyZW50T2Zmc2V0ICYmICR0by5pbmRleCgpIDwgJHRvLnBhcmVudC5jaGlsZENvdW50ID8gJGZyb20gOiAkdG8pLnBvcztcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZVxuYmxvY2suXG4qL1xuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGN1cnNvci5kZXB0aCA+IDEgJiYgJGN1cnNvci5hZnRlcigpICE9ICRjdXJzb3IuZW5kKC0xKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ3JlYXRlIGEgdmFyaWFudCBvZiBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jaykgdGhhdCB1c2VzXG5hIGN1c3RvbSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG5ld2x5IHNwbGl0IG9mZiBibG9jay5cbiovXG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnQuaXNCbG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBsZXQgZGVmbHQgPSAkZnJvbS5kZXB0aCA9PSAwID8gbnVsbCA6IGRlZmF1bHRCbG9ja0F0KCRmcm9tLm5vZGUoLTEpLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoLTEpKSk7XG4gICAgICAgICAgICBsZXQgc3BsaXRUeXBlID0gc3BsaXROb2RlICYmIHNwbGl0Tm9kZSgkdG8ucGFyZW50LCBhdEVuZCk7XG4gICAgICAgICAgICBsZXQgdHlwZXMgPSBzcGxpdFR5cGUgPyBbc3BsaXRUeXBlXSA6IGF0RW5kICYmIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdClcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMgPSBbeyB0eXBlOiBkZWZsdCB9XTtcbiAgICAgICAgICAgICAgICBjYW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT0gZGVmbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiAkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblNwbGl0IHRoZSBwYXJlbnQgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbi4gSWYgdGhlIHNlbGVjdGlvbiBpcyBhIHRleHRcbnNlbGVjdGlvbiwgYWxzbyBkZWxldGUgaXRzIGNvbnRlbnQuXG4qL1xuY29uc3Qgc3BsaXRCbG9jayA9IHNwbGl0QmxvY2tBcygpO1xuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxucmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuY29uc3Qgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgbGV0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfSkpO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbmFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbiwgcG9zO1xuICAgIGxldCBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgIGlmIChzYW1lID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBwb3MgPSAkZnJvbS5iZWZvcmUoc2FtZSk7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgIWJlZm9yZS50eXBlLmNvbXBhdGlibGVDb250ZW50KGFmdGVyLnR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBjYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHJcbiAgICAgICAgICAgIC5jbGVhckluY29tcGF0aWJsZSgkcG9zLnBvcywgYmVmb3JlLnR5cGUsIGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpXG4gICAgICAgICAgICAuam9pbigkcG9zLnBvcylcbiAgICAgICAgICAgIC5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgY29ubiwgbWF0Y2g7XG4gICAgaWYgKGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGNhbkRlbEFmdGVyID0gJGN1dC5wYXJlbnQuY2FuUmVwbGFjZSgkY3V0LmluZGV4KCksICRjdXQuaW5kZXgoKSArIDEpO1xuICAgIGlmIChjYW5EZWxBZnRlciAmJlxuICAgICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgICAgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBTbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgICAgICAgIGxldCBqb2luQXQgPSBlbmQgKyAyICogY29ubi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2FuSm9pbih0ci5kb2MsIGpvaW5BdCkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luQXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBzZWxBZnRlciA9IFNlbGVjdGlvbi5maW5kRnJvbSgkY3V0LCAxKTtcbiAgICBsZXQgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmIHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIsIHRydWUpICYmIHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikpIHtcbiAgICAgICAgbGV0IGF0ID0gYmVmb3JlLCB3cmFwID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHdyYXAucHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBhdCA9IGF0Lmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgICAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJUZXh0ID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBhZnRlckRlcHRoKys7XG4gICAgICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBGcmFnbWVudC5mcm9tKHdyYXBbaV0uY29weShlbmQpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIHdyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgU2xpY2UoZW5kLCB3cmFwLmxlbmd0aCwgMCksIDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRleHRibG9ja1NpZGUoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sICRwb3MgPSBzaWRlIDwgMCA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7XG4gICAgICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkcG9zLm5vZGUoZGVwdGgpLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBzaWRlIDwgMCA/ICRwb3Muc3RhcnQoZGVwdGgpIDogJHBvcy5lbmQoZGVwdGgpKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKC0xKTtcbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKDEpO1xuLy8gUGFyYW1ldGVyaXplZCBjb21tYW5kc1xuLyoqXG5XcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG5hdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbihub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHdyYXBwaW5nID0gcmFuZ2UgJiYgZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAoIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci53cmFwKHJhbmdlLCB3cmFwcGluZykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoICYmICFhcHBsaWNhYmxlOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBhdHRycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGxpY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgIGxldCBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG5naXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5kb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xub2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbmRvY3VtZW50LlxuKi9cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGVtcHR5LCAkY3Vyc29yLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBoYXMgPSBmYWxzZSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgIWhhcyAmJiBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaGFzID0gc3RhdGUuZG9jLnJhbmdlSGFzTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSAkZnJvbS5wb3MsIHRvID0gJHRvLnBvcywgc3RhcnQgPSAkZnJvbS5ub2RlQWZ0ZXIsIGVuZCA9ICR0by5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlU3RhcnQgPSBzdGFydCAmJiBzdGFydC5pc1RleHQgPyAvXlxccyovLmV4ZWMoc3RhcnQudGV4dClbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUVuZCA9IGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICAgIHJldHVybiAodHIpID0+IHtcbiAgICAgICAgaWYgKCF0ci5pc0dlbmVyaWMpXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2godHIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHIubWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgICAgICAgbWFwLmZvckVhY2goKF9zLCBfZSwgZnJvbSwgdG8pID0+IHJhbmdlcy5wdXNoKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBqb2luYWJsZSBwb2ludHMgZXhpc3QgaW5zaWRlIHRob3NlIHJhbmdlcyxcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgICAgIGxldCBqb2luYWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaV0sIHRvID0gcmFuZ2VzW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSwgcGFyZW50ID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIHRoZSBqb2luYWJsZSBwb2ludHNcbiAgICAgICAgam9pbmFibGUuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gam9pbmFibGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbmFibGVbaV0pKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbmFibGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9O1xufVxuLyoqXG5XcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG50d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbk5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbndoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG5hcnJheS5cbiovXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gICAgbGV0IGNhbkpvaW4gPSBBcnJheS5pc0FycmF5KGlzSm9pbmFibGUpID8gKG5vZGUpID0+IGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMVxuICAgICAgICA6IGlzSm9pbmFibGU7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbn1cbi8qKlxuQ29tYmluZSBhIG51bWJlciBvZiBjb21tYW5kIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uICh3aGljaFxuY2FsbHMgdGhlbSBvbmUgYnkgb25lIHVudGlsIG9uZSByZXR1cm5zIHRydWUpLlxuKi9cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoLi4uY29tbWFuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxubGV0IGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG5sZXQgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG4vKipcbkEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG5CaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuXG4qICoqRW50ZXIqKiB0byBgbmV3bGluZUluQ29kZWAsIGBjcmVhdGVQYXJhZ3JhcGhOZWFyYCwgYGxpZnRFbXB0eUJsb2NrYCwgYHNwbGl0QmxvY2tgXG4qICoqTW9kLUVudGVyKiogdG8gYGV4aXRDb2RlYFxuKiAqKkJhY2tzcGFjZSoqIGFuZCAqKk1vZC1CYWNrc3BhY2UqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5CYWNrd2FyZGAsIGBzZWxlY3ROb2RlQmFja3dhcmRgXG4qICoqRGVsZXRlKiogYW5kICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLWEqKiB0byBgc2VsZWN0QWxsYFxuKi9cbmNvbnN0IHBjQmFzZUtleW1hcCA9IHtcbiAgICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICAgIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICAgIFwiQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIkRlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbi8qKlxuQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4qKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG5DdHJsLURlbGV0ZS5cbiovXG5jb25zdCBtYWNCYXNlS2V5bWFwID0ge1xuICAgIFwiQ3RybC1oXCI6IHBjQmFzZUtleW1hcFtcIkJhY2tzcGFjZVwiXSxcbiAgICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJDdHJsLWFcIjogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gICAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yIChsZXQga2V5IGluIHBjQmFzZUtleW1hcClcbiAgICBtYWNCYXNlS2V5bWFwW2tleV0gPSBwY0Jhc2VLZXltYXBba2V5XTtcbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBvcyAhPSBcInVuZGVmaW5lZFwiICYmIG9zLnBsYXRmb3JtID8gb3MucGxhdGZvcm0oKSA9PSBcImRhcndpblwiIDogZmFsc2U7XG4vKipcbkRlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG5bYHBjQmFzZWtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG5bYG1hY0Jhc2VLZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG4qL1xuY29uc3QgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblRleHRibG9ja0JhY2t3YXJkLCBqb2luVGV4dGJsb2NrRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNlbGVjdFRleHRibG9ja0VuZCwgc2VsZWN0VGV4dGJsb2NrU3RhcnQsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0FzLCBzcGxpdEJsb2NrS2VlcE1hcmtzLCB0b2dnbGVNYXJrLCB3cmFwSW4gfTtcbiJdLCJuYW1lcyI6WyJsaWZ0VGFyZ2V0IiwicmVwbGFjZVN0ZXAiLCJSZXBsYWNlU3RlcCIsImNhbkpvaW4iLCJqb2luUG9pbnQiLCJjYW5TcGxpdCIsIlJlcGxhY2VBcm91bmRTdGVwIiwiZmluZFdyYXBwaW5nIiwiU2xpY2UiLCJGcmFnbWVudCIsIk5vZGVTZWxlY3Rpb24iLCJTZWxlY3Rpb24iLCJUZXh0U2VsZWN0aW9uIiwiQWxsU2VsZWN0aW9uIiwiZGVsZXRlU2VsZWN0aW9uIiwic3RhdGUiLCJkaXNwYXRjaCIsInNlbGVjdGlvbiIsImVtcHR5IiwidHIiLCJzY3JvbGxJbnRvVmlldyIsImF0QmxvY2tTdGFydCIsInZpZXciLCIkY3Vyc29yIiwiZW5kT2ZUZXh0YmxvY2siLCJwYXJlbnRPZmZzZXQiLCJqb2luQmFja3dhcmQiLCIkY3V0IiwiZmluZEN1dEJlZm9yZSIsInJhbmdlIiwiYmxvY2tSYW5nZSIsInRhcmdldCIsImxpZnQiLCJiZWZvcmUiLCJub2RlQmVmb3JlIiwidHlwZSIsInNwZWMiLCJpc29sYXRpbmciLCJkZWxldGVCYXJyaWVyIiwicGFyZW50IiwiY29udGVudCIsInNpemUiLCJ0ZXh0YmxvY2tBdCIsImlzU2VsZWN0YWJsZSIsImRlbFN0ZXAiLCJkb2MiLCJhZnRlciIsInNsaWNlIiwidG8iLCJmcm9tIiwic3RlcCIsInNldFNlbGVjdGlvbiIsImZpbmRGcm9tIiwicmVzb2x2ZSIsIm1hcHBpbmciLCJtYXAiLCJwb3MiLCJjcmVhdGUiLCJub2RlU2l6ZSIsImlzQXRvbSIsImRlcHRoIiwiZGVsZXRlIiwiam9pblRleHRibG9ja0JhY2t3YXJkIiwiam9pblRleHRibG9ja3NBcm91bmQiLCJqb2luVGV4dGJsb2NrRm9yd2FyZCIsImF0QmxvY2tFbmQiLCJmaW5kQ3V0QWZ0ZXIiLCJiZWZvcmVUZXh0IiwiYmVmb3JlUG9zIiwiaXNUZXh0YmxvY2siLCJjaGlsZCIsImxhc3RDaGlsZCIsIm5vZGVBZnRlciIsImFmdGVyVGV4dCIsImFmdGVyUG9zIiwiZmlyc3RDaGlsZCIsIm5vZGUiLCJzaWRlIiwib25seSIsInNjYW4iLCJjaGlsZENvdW50Iiwic2VsZWN0Tm9kZUJhY2t3YXJkIiwiJGhlYWQiLCIkcG9zIiwiaSIsImluZGV4Iiwiam9pbkZvcndhcmQiLCJzZWxlY3ROb2RlRm9yd2FyZCIsImpvaW5VcCIsInNlbCIsIm5vZGVTZWwiLCJwb2ludCIsImpvaW4iLCJqb2luRG93biIsIiRmcm9tIiwiJHRvIiwibmV3bGluZUluQ29kZSIsIiRhbmNob3IiLCJjb2RlIiwic2FtZVBhcmVudCIsImluc2VydFRleHQiLCJkZWZhdWx0QmxvY2tBdCIsIm1hdGNoIiwiZWRnZUNvdW50IiwiZWRnZSIsImhhc1JlcXVpcmVkQXR0cnMiLCJleGl0Q29kZSIsImFib3ZlIiwiaW5kZXhBZnRlciIsImNvbnRlbnRNYXRjaEF0IiwiY2FuUmVwbGFjZVdpdGgiLCJyZXBsYWNlV2l0aCIsImNyZWF0ZUFuZEZpbGwiLCJuZWFyIiwiY3JlYXRlUGFyYWdyYXBoTmVhciIsImlubGluZUNvbnRlbnQiLCJpbnNlcnQiLCJsaWZ0RW1wdHlCbG9jayIsImVuZCIsInNwbGl0Iiwic3BsaXRCbG9ja0FzIiwic3BsaXROb2RlIiwiaXNCbG9jayIsImF0RW5kIiwiZGVmbHQiLCJzcGxpdFR5cGUiLCJ0eXBlcyIsInVuZGVmaW5lZCIsImNhbiIsImZpcnN0IiwiJGZpcnN0Iiwic2V0Tm9kZU1hcmt1cCIsInNwbGl0QmxvY2siLCJzcGxpdEJsb2NrS2VlcE1hcmtzIiwibWFya3MiLCJzdG9yZWRNYXJrcyIsImVuc3VyZU1hcmtzIiwic2VsZWN0UGFyZW50Tm9kZSIsInNhbWUiLCJzaGFyZWREZXB0aCIsInNlbGVjdEFsbCIsImpvaW5NYXliZUNsZWFyIiwiY29tcGF0aWJsZUNvbnRlbnQiLCJjYW5SZXBsYWNlIiwiY2xlYXJJbmNvbXBhdGlibGUiLCJjb25uIiwiY2FuRGVsQWZ0ZXIiLCJtYXRjaFR5cGUiLCJ2YWxpZEVuZCIsIndyYXAiLCJsZW5ndGgiLCJjb3B5Iiwiam9pbkF0Iiwic2VsQWZ0ZXIiLCJhdCIsInB1c2giLCJhZnRlckRlcHRoIiwic2VsZWN0VGV4dGJsb2NrU2lkZSIsImlzSW5saW5lIiwic3RhcnQiLCJzZWxlY3RUZXh0YmxvY2tTdGFydCIsInNlbGVjdFRleHRibG9ja0VuZCIsIndyYXBJbiIsIm5vZGVUeXBlIiwiYXR0cnMiLCJ3cmFwcGluZyIsInNldEJsb2NrVHlwZSIsImFwcGxpY2FibGUiLCJyYW5nZXMiLCJub2Rlc0JldHdlZW4iLCJoYXNNYXJrdXAiLCJtYXJrQXBwbGllcyIsImFsbG93c01hcmtUeXBlIiwidG9nZ2xlTWFyayIsIm1hcmtUeXBlIiwiaXNJblNldCIsInJlbW92ZVN0b3JlZE1hcmsiLCJhZGRTdG9yZWRNYXJrIiwiaGFzIiwicmFuZ2VIYXNNYXJrIiwicmVtb3ZlTWFyayIsInNwYWNlU3RhcnQiLCJpc1RleHQiLCJleGVjIiwidGV4dCIsInNwYWNlRW5kIiwiYWRkTWFyayIsIndyYXBEaXNwYXRjaEZvckpvaW4iLCJpc0pvaW5hYmxlIiwiaXNHZW5lcmljIiwibWFwcyIsImoiLCJmb3JFYWNoIiwiX3MiLCJfZSIsImpvaW5hYmxlIiwibWF5YmVDaGlsZCIsImluZGV4T2YiLCJzb3J0IiwiYSIsImIiLCJhdXRvSm9pbiIsImNvbW1hbmQiLCJBcnJheSIsImlzQXJyYXkiLCJuYW1lIiwiY2hhaW5Db21tYW5kcyIsImNvbW1hbmRzIiwiYmFja3NwYWNlIiwiZGVsIiwicGNCYXNlS2V5bWFwIiwibWFjQmFzZUtleW1hcCIsImtleSIsIm1hYyIsIm5hdmlnYXRvciIsInRlc3QiLCJwbGF0Zm9ybSIsIm9zIiwiYmFzZUtleW1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-commands/dist/index.js\n");

/***/ })

};
;